import numpy as np
import torch

class MassSpringDamperModel:
    """Mass-Spring-Damper system for modeling compliance."""

    def __init__(
        self,
        n_dofs: int,
        dt: float,
        base_inertia: float,
        base_stiffness: float,
        stiffness_scales: dict[int, float],
        num_envs=1,
        device="cuda"
    ):
        """                              
        Initialize MSD system.

        Args:
            n_dofs: Total number of DOFs in the system
            dt: Simulation timestep in seconds
            base_inertia: Base inertia value applied to all DOFs
            base_stiffness: Base stiffness value, scaled per-DOF by stiffness_scales
            stiffness_scales: Mapping of DOF index to stiffness scale factor.     
                Only DOFs present in this dict are modeled as compliant.
            num_envs: Number of parallel environments for batched simulation.
            device: Torch device for computation ('cuda' or 'cpu')
        """
        self.n_dofs = n_dofs
        self.dt = dt
        self.active_idx = np.array(sorted(stiffness_scales.keys()))
        self.n_active = len(self.active_idx)
        self.num_envs = num_envs
        self.device = device

        # Initialize MSD matrices (numpy for matrix computation)
        self.M = np.ones(n_dofs) * base_inertia
        self.K = np.zeros(n_dofs)
        self.D = np.zeros(n_dofs)

        for dof_idx, scale in stiffness_scales.items():
            self.K[dof_idx] = base_stiffness * scale

        # Compute critical damping: D = 2*sqrt(M*K)
        self.D = 2 * np.sqrt(self.M * self.K)

        # Compute discrete-time state-space matrices and convert to Torch
        Ad_np, Bd_np = self._compute_discrete_matrices()
        self.Ad = torch.tensor(Ad_np, dtype=torch.float32, device=device)
        self.Bd = torch.tensor(Bd_np, dtype=torch.float32, device=device)

        # Convert active_idx to torch for indexing
        self.active_idx_torch = torch.tensor(self.active_idx, dtype=torch.long, device=device)

        # MSD state: batched [num_envs, n_active] for q_def and qd_def
        self.state = self._create_msd_state()

    def _create_msd_state(self):
        """Create MSD state dictionary for tracking deformations (only active DOFs)."""
        return {
            'q_def': torch.zeros((self.num_envs, self.n_active), dtype=torch.float32, device=self.device),
            'qd_def': torch.zeros((self.num_envs, self.n_active), dtype=torch.float32, device=self.device),
        }

    def get_state_dict(self):
        """Get current MSD state as dictionary."""
        return self.state

    def _compute_discrete_matrices(self):
        """Compute discrete-time state-space matrices for active DOFs."""
        from scipy.linalg import expm

        active_idx = self.active_idx

        if self.n_active == 0:
            return np.eye(0), np.zeros((0, 0)), active_idx

        M_active = self.M[self.active_idx]
        D_active = self.D[self.active_idx]
        K_active = self.K[self.active_idx]

        # Build continuous-time state matrices (reduced dimension)
        # A = [[0, I], [-M^-1*K, -M^-1*D]]
        A = np.zeros((2 * self.n_active, 2 * self.n_active))
        B = np.zeros((2 * self.n_active, self.n_active))

        # Upper-right block: I
        A[: self.n_active, self.n_active :] = np.eye(self.n_active)

        # Lower-left block: -M^-1*K
        A[self.n_active :, : self.n_active] = np.diag(-K_active / M_active)

        # Lower-right block: -M^-1*D
        A[self.n_active :, self.n_active :] = np.diag(-D_active / M_active)

        # Input matrix B = [[0], [M^-1]]
        B[self.n_active :, :] = np.diag(1.0 / M_active)

        # Compute discrete-time matrices
        # Ad = exp(A * dt)
        Ad = expm(A * self.dt)

        # Bd = A^-1 * (Ad - I) * B
        A_inv = np.linalg.inv(A)
        Bd = A_inv @ (Ad - np.eye(2 * self.n_active)) @ B

        return Ad, Bd

    def update_msd_state_discrete(self, external_torques: torch.Tensor):
        """
        Update Mass-Spring-Damper state using analytical discrete-time solution.
        Batched computation for all environments.

        Uses precomputed discrete-time state-space matrices:
            x[k+1] = Ad*x[k] + Bd*u[k]
            where x = [q_def; qd_def], u = tau_ext (active DOFs only)

        Args:
            external_torques: External torques on joints [num_envs, n_dofs] - full DOF vector
        """
        if self.n_active == 0:
            return  # No active DOFs

        # Ensure torques are on the correct device
        external_torques = external_torques.to(device=self.device)

        # Extract only active DOF torques: [num_envs, n_active]
        external_torques_active = external_torques[:, self.active_idx_torch]

        # Pack state vector: x = [q_def; qd_def] (active DOFs only)
        x = torch.cat([self.state["q_def"], self.state["qd_def"]], dim=1)

        # Discrete-time state update: x[k+1] = Ad @ x[k] + Bd @ u[k]
        x_next = x @ self.Ad.T + external_torques_active @ self.Bd.T

        # Unpack state vector (active DOFs only)
        # x_next shape: [num_envs, 2*n_active] where first n_active cols are q_def
        self.state["q_def"][:] = x_next[:, :self.n_active]
        self.state["qd_def"][:] = x_next[:, self.n_active:]

    def reset(self, env_ids: torch.Tensor = None):
        """Reset MSD state to zero for specified environments."""
        if env_ids is None:
            self.state['q_def'][:] = 0.0
            self.state['qd_def'][:] = 0.0
        else:
            self.state['q_def'][env_ids] = 0.0
            self.state['qd_def'][env_ids] = 0.0